import '../flags.dart';
import '_utils.dart';

String bash(String name, String exec) {
  final escapedName = nameForVar(name);
  return '''# Coal bash completion for $name
#----------------------------------------
# This file is generated by the Coal TAB.
#----------------------------------------
# Date: ${DateTime.now()}
#----------------------------------------

# debug completion
${escapedName}_debug() {
  if [[ -n \${BASH_COMP_DEBUG_FILE:-} ]]; then
    echo "\$*" >> "\${BASH_COMP_DEBUG_FILE}"
  fi
}

# handle completions
${escapedName}_complete() {
  local cur prev words cword
  _get_comp_words_by_ref -n "=:" cur prev words cword

  local requestComp out directive

  # Build the command to get completions
  requestComp="$exec complete -- \${words[@]:1}"

  # Add an empty parameter if the last parameter is complete
  if [[ -z "\$cur" ]]; then
    requestComp="\$requestComp ''"
  fi

  # Get completions from the program
  out=\$(eval "\$requestComp" 2>/dev/null)

  # Extract directive if present
  directive=0
  if [[ "\$out" == *:* ]]; then
    directive=\${out##*:}
    out=\${out%:*}
  fi

  # Process completions based on directive
  if [[ \$((directive & ${ShellCompleteDirective.error})) -ne 0 ]]; then
    return
  fi

  Apply directives
  if [[ \$((directive & ${ShellCompleteDirective.noSpace})) -ne 0 ]]; then
    compopt -o nospace
  fi
  if [[ \$((directive & ${ShellCompleteDirective.keepOrder})) -ne 0 ]]; then
    compopt -o nosort
  fi
  if [[ \$((directive & ${ShellCompleteDirective.noFileCompletion})) -ne 0 ]]; then
    compopt +o default
  fi

  # Handle file extension filtering
  if [[ \$((directive & ${ShellCompleteDirective.filterFileExtension})) -ne 0 ]]; then
    local filter=""
    for ext in \$out; do
      filter="\$filter|\$ext"
    done
    filter="\\.(\$filter)"
    compopt -o filenames
    COMPREPLY=( \$(compgen -f -X "!\$filter" -- "\$cur") )
    return
  fi

  # Handle directory filtering
  if [[ \$((directive & ${ShellCompleteDirective.filterDirectory})) -ne 0 ]]; then
    compopt -o dirnames
    COMPREPLY=( \$(compgen -d -- "\$cur") )
    return
  fi

  # Process completions
  local IFS=\$'\\n'
  local tab=\$(printf '\\t')

  # Parse completions with descriptions
  local completions=()
  while read -r comp; do
    if [[ "\$comp" == *\$tab* ]]; then
      # Split completion and description
      local value=\${comp%%\$tab*}
      local desc=\${comp#*\$tab}
      completions+=("\$value")
    else
      completions+=("\$comp")
    fi
  done <<< "\$out"

  # Return completions
  COMPREPLY=( \$(compgen -W "\${completions[*]}" -- "\$cur") )
}

# Register completion
complete -F ${escapedName}_complete $name
''';
}
