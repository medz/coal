// reference: https://github.com/spf13/cobra/blob/main/bash_completionsV2.go

import '../flags.dart';
import '_utils.dart';

String bashScript(String name, String exec) {
  final escapedName = nameForVar(name);
  return '''# bash completion for $name
#----------------------------------------
# This file is generated by the Coal TAB.
#----------------------------------------
# Date: ${DateTime.now()}
#----------------------------------------

# Define shell completion directives
readonly ShellCompDirectiveError=${ShellCompDirective.error}
readonly ShellCompDirectiveNoSpace=${ShellCompDirective.noSpace}
readonly ShellCompDirectiveNoFileComp=${ShellCompDirective.noFileComp}
readonly ShellCompDirectiveFilterFileExt=${ShellCompDirective.filterFileExt}
readonly ShellCompDirectiveFilterDirs=${ShellCompDirective.filterDirs}
readonly ShellCompDirectiveKeepOrder=${ShellCompDirective.keepOrder}

# Function to debug completion
__${escapedName}_debug() {
    if [[ -n \${BASH_COMP_DEBUG_FILE:-} ]]; then
        echo "\$*" >> "\${BASH_COMP_DEBUG_FILE}"
    fi
}

# Function to handle completions
__${escapedName}_complete() {
    local cur prev words cword
    _get_comp_words_by_ref -n "=:" cur prev words cword

    local requestComp out directive

    # Build the command to get completions
    requestComp="$exec complete -- \${words[@]:1}"

    # Add an empty parameter if the last parameter is complete
    if [[ -z "\$cur" ]]; then
        requestComp="\$requestComp ''"
    fi

    # Get completions from the program
    out=\$(eval "\$requestComp" 2>/dev/null)

    # Extract directive if present
    directive=0
    if [[ "\$out" == *:* ]]; then
        directive=\${out##*:}
        out=\${out%:*}
    fi

    # Process completions based on directive
    if [[ \$((directive & \$ShellCompDirectiveError)) -ne 0 ]]; then
        # Error, no completion
        return
    fi

    # Apply directives
    if [[ \$((directive & \$ShellCompDirectiveNoSpace)) -ne 0 ]]; then
        compopt -o nospace
    fi
    if [[ \$((directive & \$ShellCompDirectiveKeepOrder)) -ne 0 ]]; then
        compopt -o nosort
    fi
    if [[ \$((directive & \$ShellCompDirectiveNoFileComp)) -ne 0 ]]; then
        compopt +o default
    fi

    # Handle file extension filtering
    if [[ \$((directive & \$ShellCompDirectiveFilterFileExt)) -ne 0 ]]; then
        local filter=""
        for ext in \$out; do
            filter="\$filter|\$ext"
        done
        filter="\\.(\$filter)"
        compopt -o filenames
        COMPREPLY=( \$(compgen -f -X "!\$filter" -- "\$cur") )
        return
    fi

    # Handle directory filtering
    if [[ \$((directive & \$ShellCompDirectiveFilterDirs)) -ne 0 ]]; then
        compopt -o dirnames
        COMPREPLY=( \$(compgen -d -- "\$cur") )
        return
    fi

    # Process completions
    local IFS=\$'\\n'
    local tab=\$(printf '\\t')

    # Parse completions with descriptions
    local completions=()
    while read -r comp; do
        if [[ "\$comp" == *\$tab* ]]; then
            # Split completion and description
            local value=\${comp%%\$tab*}
            local desc=\${comp#*\$tab}
            completions+=("\$value")
        else
            completions+=("\$comp")
        fi
    done <<< "\$out"

    # Return completions
    COMPREPLY=( \$(compgen -W "\${completions[*]}" -- "\$cur") )
}

# Register completion function
complete -F __${escapedName}_complete $name
''';
}
