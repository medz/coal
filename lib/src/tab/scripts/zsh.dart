// Reference: https://github.com/spf13/cobra/blob/main/zsh_completions.go

import '../flags.dart';
import '_utils.dart';

String zshScript(String name, String exec) {
  final escapedName = nameForVar(name);
  return '''#compdef $name
compdef ${escapedName}_complete $name

# Coal bash completion for $name
#----------------------------------------
# This file is generated by the Coal TAB.
#----------------------------------------
# Date: ${DateTime.now()}
#----------------------------------------

${escapedName}_debug() {
  local file="\$BASH_COMP_DEBUG_FILE"
  if [[ -n \${file} ]]; then
    echo "\$*" >> "\${file}"
  fi
}

${escapedName}_complete() {
  local lastParam lastChar flagPrefix requestComp out directive comp lastComp noSpace keepOrder
  local -a completions

  ${escapedName}_debug "\\n========= starting completion logic =========="
  ${escapedName}_debug "CURRENT: \${CURRENT}, words[*]: \${words[*]}"

  words=( "\${=words[1,CURRENT]}" )
  ${escapedName}_debug "Truncated words[*]: \${words[*]},"

  lastParam=\${words[-1]}
  lastChar=\${lastParam[-1]}
  ${escapedName}_debug "lastParam: \${lastParam}, lastChar: \${lastChar}"

  setopt local_options BASH_REMATCH
  if [[ "\${lastParam}" =~ '-.*=' ]]; then
    flagPrefix="-P \${BASH_REMATCH}"
  fi

  local -a args_to_quote=("\${(@)words[2,-1]}")
  if [ "\${lastChar}" = "" ]; then
    ${escapedName}_debug "Adding extra empty parameter"
    args_to_quote+=("")
  fi

  local quoted_args=("\${(@q)args_to_quote}")
  requestComp="$exec complete -- \${quoted_args[*]}"
  ${escapedName}_debug "About to call: eval \${requestComp}"

  out=\$(eval \${requestComp} 2>/dev/null)
  ${escapedName}_debug "completion output: \${out}"

  local lastLine
  while IFS='\n' read -r line; do
    lastLine=\${line}
  done < <(printf "%s\n" "\${out[@]}")
  ${escapedName}_debug "last line: \${lastLine}"

  if [ "\${lastLine[1]}" = : ]; then
    directive=\${lastLine[2,-1]}
    local suffix
    (( suffix=\${#lastLine}+2))
    out=\${out[1,-\$suffix]}
  else
    ${escapedName}_debug "No directive found.  Setting to default"
    directive=0
  fi

  ${escapedName}_debug "directive: \${directive}"
  ${escapedName}_debug "completions: \${out}"
  ${escapedName}_debug "flagPrefix: \${flagPrefix}"

  if [ \$((directive & ${ShellCompleteDirective.error})) -ne 0 ]; then
    ${escapedName}_debug "Completion received error. Ignoring completions."
    return
  fi

  local activeHelpMarker="%"
  local endIndex=\${#activeHelpMarker}
  local startIndex=\$((\${#activeHelpMarker}+1))
  local hasActiveHelp=0
  while IFS='\n' read -r comp; do
    if [ "\${comp[1,\$endIndex]}" = "\$activeHelpMarker" ];then
      ${escapedName}_debug "ActiveHelp found: \$comp"
      comp="\${comp[\$startIndex,-1]}"
      if [ -n "\$comp" ]; then
        compadd -x "\${comp}"
        ${escapedName}_debug "ActiveHelp will need delimiter"
        hasActiveHelp=1
      fi
      continue
    fi

    if [ -n "\$comp" ]; then
      comp=\${comp//:/\\:}

      local tab="\$(printf '\\t')"
      comp=\${comp//\$tab/:}

      ${escapedName}_debug "Adding completion: \${comp}"
      completions+=\${comp}
      lastComp=\$comp
    fi
  done < <(printf "%s\n" "\${out[@]}")

  if [ \$hasActiveHelp -eq 1 ]; then
    if [ \${#completions} -ne 0 ] || [ \$((directive & ${ShellCompleteDirective.noFileCompletion})) -eq 0 ]; then
      ${escapedName}_debug "Adding activeHelp delimiter"
      compadd -x "--"
      hasActiveHelp=0
    fi
  fi

  if [ \$((directive & ${ShellCompleteDirective.noSpace})) -ne 0 ]; then
    ${escapedName}_debug "Activating nospace."
    noSpace="-S ''"
  fi

  if [ \$((directive & ${ShellCompleteDirective.keepOrder})) -ne 0 ]; then
    ${escapedName}_debug "Activating keep order."
    keepOrder="-V"
  fi

  if [ \$((directive & ${ShellCompleteDirective.filterFileExtension})) -ne 0 ]; then
    local filteringCmd
    filteringCmd='_files'
    for filter in \${completions[@]}; do
        if [ \${filter[1]} != '*' ]; then
            filter="\\*.\$filter"
        fi
        filteringCmd+=" -g \$filter"
    done
    filteringCmd+=" \${flagPrefix}"

    ${escapedName}_debug "File filtering command: \$filteringCmd"
    _arguments '*:filename:'"\$filteringCmd"
  elif [ \$((directive & ${ShellCompleteDirective.filterDirectory})) -ne 0 ]; then
    local subdir
    subdir="\${completions[1]}"
    if [ -n "\$subdir" ]; then
      ${escapedName}_debug "Listing directories in \$subdir"
      pushd "\${subdir}" >/dev/null 2>&1
    else
      ${escapedName}_debug "Listing directories in ."
    fi

    local result
    _arguments '*:dirname:_files -/'" \${flagPrefix}"
    result=\$?
    if [ -n "\$subdir" ]; then
      popd >/dev/null 2>&1
    fi
    return \$result
  else
    ${escapedName}_debug "Calling _describe"
    if eval _describe \$keepOrder "completions" completions -Q \${flagPrefix} \${noSpace}; then
      ${escapedName}_debug "_describe found some completions"
      return 0
    else
      ${escapedName}_debug "_describe did not find completions."
      ${escapedName}_debug "Checking if we should do file completion."
      if [ \$((directive & ${ShellCompleteDirective.noFileCompletion})) -ne 0 ]; then
        ${name}_debug "deactivating file completion"
        return 0
      else
        ${escapedName}_debug "Activating file completion"
        _arguments '*:filename:_files'" \${flagPrefix}"
      fi
    fi
  fi
}
''';
}
