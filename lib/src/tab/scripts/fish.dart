// reference: https://github.com/spf13/cobra/blob/main/bash_completionsV2.go

import '../flags.dart';
import '_utils.dart';

String fishScript(String name, String exec) {
  final escapedName = nameForVar(name);
  return '''# fish completion for $name -*- shell-script -*-
#----------------------------------------
# This file is generated by the Coal TAB.
#----------------------------------------
# Date: ${DateTime.now()}
#----------------------------------------

# Define shell completion directives
set -l ShellCompDirectiveError ${ShellCompDirective.error}
set -l ShellCompDirectiveNoSpace ${ShellCompDirective.noSpace}
set -l ShellCompDirectiveNoFileComp ${ShellCompDirective.noFileComp}
set -l ShellCompDirectiveFilterFileExt ${ShellCompDirective.filterFileExt}
set -l ShellCompDirectiveFilterDirs ${ShellCompDirective.filterDirs}
set -l ShellCompDirectiveKeepOrder ${ShellCompDirective.keepOrder}

function __${escapedName}_debug
    set -l file "\$BASH_COMP_DEBUG_FILE"
    if test -n "\$file"
        echo "\$argv" >> \$file
    end
end

function __${escapedName}_perform_completion
    __${escapedName}_debug "Starting __${escapedName}_perform_completion"

    # Extract all args except the completion flag
    set -l args (string match -v -- "--completion=" (commandline -opc))

    # Extract the current token being completed
    set -l current_token (commandline -ct)

    # Check if current token starts with a dash
    set -l flag_prefix ""
    if string match -q -- "-*" \$current_token
        set flag_prefix "--flag="
    end

    __${escapedName}_debug "Current token: \$current_token"
    __${escapedName}_debug "All args: \$args"

    # Call the completion program and get the results
    set -l requestComp "$exec complete -- \$args"
    __${escapedName}_debug "Calling \$requestComp"
    set -l results (eval \$requestComp 2> /dev/null)

    # Some programs may output extra empty lines after the directive.
    # Let's ignore them or else it will break completion.
    # Ref: https://github.com/spf13/cobra/issues/1279
    for line in \$results[-1..1]
        if test (string sub -s 1 -l 1 -- \$line) = ":"
            # The directive
            set -l directive (string sub -s 2 -- \$line)
            set -l directive_num (math \$directive)
            break
        end
    end

    # No directive specified, use default
    if not set -q directive_num
        set directive_num 0
    end

    __${escapedName}_debug "Directive: \$directive_num"

    # Process completions based on directive
    if test \$directive_num -eq \$ShellCompDirectiveError
        # Error code. No completion.
        __${escapedName}_debug "Received error directive: aborting."
        return 1
    end

    # Filter out the directive (last line)
    if test (count \$results) -gt 0 -a (string sub -s 1 -l 1 -- \$results[-1]) = ":"
        set results \$results[1..-2]
    end

    # No completions, let fish handle file completions unless forbidden
    if test (count \$results) -eq 0
        if test \$directive_num -ne \$ShellCompDirectiveNoFileComp
            __${escapedName}_debug "No completions, performing file completion"
            return 1
        end
        __${escapedName}_debug "No completions, but file completion forbidden"
        return 0
    end

    # Filter file extensions
    if test \$directive_num -eq \$ShellCompDirectiveFilterFileExt
        __${escapedName}_debug "File extension filtering"
        set -l file_extensions
        for item in \$results
            if test -n "\$item" -a (string sub -s 1 -l 1 -- \$item) != "-"
                set -a file_extensions "*\$item"
            end
        end
        __${escapedName}_debug "File extensions: \$file_extensions"

        # Use the file extensions as completions
        set -l completions
        for ext in \$file_extensions
            # Get all files matching the extension
            set -a completions (string replace -r '^.*/' '' -- \$ext)
        end

        for item in \$completions
            echo -e "\$item\t"
        end
        return 0
    end

    # Filter directories
    if test \$directive_num -eq \$ShellCompDirectiveFilterDirs
        __${escapedName}_debug "Directory filtering"
        set -l dirs
        for item in \$results
            if test -d "\$item"
                set -a dirs "\$item/"
            end
        end

        for item in \$dirs
            echo -e "\$item\t"
        end
        return 0
    end

    # Process remaining completions
    for item in \$results
        if test -n "\$item"
            # Check if the item has a description
            if string match -q "*\t*" -- "\$item"
                set -l completion_parts (string split \t -- "\$item")
                set -l comp \$completion_parts[1]
                set -l desc \$completion_parts[2]

                # Add the completion and description
                echo -e "\$comp\t\$desc"
            else
                # Add just the completion
                echo -e "\$item\t"
            end
        end
    end

    # If directive contains NoSpace, tell fish not to add a space after completion
    if test (math "\$directive_num & \$ShellCompDirectiveNoSpace") -ne 0
        return 2
    end

    return 0
end

# Set up the completion for the $name command
complete -c $name -f -a "(eval __${escapedName}_perform_completion)"
''';
}
